/** * $Id: FlabotLauncherConfigurationDelegate.java,v 1.10 2006/04/06 00:18:52 dacostae Exp $ * $Author: dacostae $ */package org.isistan.flabot.launcher.delegate;

import java.lang.reflect.InvocationTargetException;import org.eclipse.core.runtime.CoreException;import org.eclipse.core.runtime.IProgressMonitor;import org.eclipse.core.runtime.IStatus;import org.eclipse.core.runtime.Status;import org.eclipse.debug.core.DebugPlugin;import org.eclipse.debug.core.ILaunch;import org.eclipse.debug.core.ILaunchConfiguration;import org.eclipse.debug.core.model.ILaunchConfigurationDelegate;import org.isistan.flabot.launcher.LaunchConfigurationConstants;import org.isistan.flabot.launcher.LauncherPlugin;import org.isistan.flabot.launcher.collection.CollectionLauncher;import org.isistan.flabot.launcher.collection.CollectionLauncherException;import org.isistan.flabot.launcher.collection.CollectionLauncherLoader;import org.isistan.flabot.launcher.context.ContextProvider;import org.isistan.flabot.launcher.context.ContextProviderException;import org.isistan.flabot.launcher.context.ContextProviderLoader;import org.isistan.flabot.trace.config.ConfigFactory;import org.isistan.flabot.trace.config.Context;import org.isistan.flabot.trace.config.TraceConfiguration;import org.isistan.flabot.util.extension.NoMatchingConstructorFoundException;import org.isistan.flabot.util.resource.PathUtil;/** *  * This delegate loads the contexts using a ContextProvider and builds * a TraceConfiguration. Finally delegates the launching to a * CollectionLauncher. *  * @author usuario * */public class FlabotLauncherConfigurationDelegate implements ILaunchConfigurationDelegate {
	/**	 * Loads Contexts, builds  a TraceConfiguration, obtains target	 * LaunchConfiguration and delegates launching to a	 * CollectionLauncher.	 */	public void launch(ILaunchConfiguration launchConfiguration, String mode, ILaunch launch, IProgressMonitor monitor) throws CoreException {		ILaunchConfiguration targetLaunchConfiguration = getTargetLaunchConfiguration(launchConfiguration);		TraceConfiguration traceConfiguration=getTraceConfiguration(launchConfiguration);				CollectionLauncher launcher=getCollectionLauncher(launchConfiguration);				try {			launcher.launch(launchConfiguration, targetLaunchConfiguration, mode, launch, monitor, traceConfiguration);		} catch (CollectionLauncherException e) {			LauncherPlugin.getDefault().getLogger().error("Couldn't launch program: {}", e);			throw new CoreException(new Status(IStatus.ERROR, LauncherPlugin.SYMBOLIC_NAME, IStatus.ERROR, "Error launching application.", null));		}
	}	/**	 * Builds a trace configuration based on the contexts returned by	 * the configured ContextProvider.	 * 	 * @param launchConfiguration	 * @return	 * @throws CoreException	 */	private TraceConfiguration getTraceConfiguration(ILaunchConfiguration launchConfiguration) throws CoreException {		ContextProvider contextProvider=getContextProvider(launchConfiguration);		Context[] contexts=null;		try {			contexts=contextProvider.getContexts(launchConfiguration);		} catch (ContextProviderException e) {			throw new CoreException(new Status(IStatus.ERROR, LauncherPlugin.SYMBOLIC_NAME, IStatus.ERROR, "Error launching application.", null));		}				TraceConfiguration traceConfiguration=ConfigFactory.eINSTANCE.createTraceConfiguration();		for (Context context : contexts) {			traceConfiguration.getContexts().add(context);		}				String outputFile=launchConfiguration.getAttribute(				LaunchConfigurationConstants.OUTPUT_FILE, "");		if(outputFile==null || outputFile.trim().length()==0) {			throw new CoreException(new Status(IStatus.ERROR, LauncherPlugin.SYMBOLIC_NAME, IStatus.ERROR, "Output file not selected.", null));		}		outputFile=PathUtil.toString(PathUtil.makeSystemAbsolute(PathUtil.fromString(outputFile)));		traceConfiguration.setOutputFileName(outputFile);				String startCollecting=launchConfiguration.getAttribute(				LaunchConfigurationConstants.START_COLLECTING, Boolean.FALSE.toString());		if(startCollecting==null || startCollecting.trim().length()==0) {			startCollecting=Boolean.FALSE.toString();		}		traceConfiguration.setStartCollecting(Boolean.valueOf(startCollecting));		return traceConfiguration;	}		/**	 * Loads the configured CollectionLauncher	 * 	 * @param launchConfiguration	 * @return	 * @throws CoreException	 */	private CollectionLauncher getCollectionLauncher(ILaunchConfiguration launchConfiguration) throws CoreException {		String collectionLauncherId=launchConfiguration.getAttribute(				LaunchConfigurationConstants.COLLECTION_LAUNCHER_ID, "");		if(collectionLauncherId.trim().length()==0) {			throw new CoreException(new Status(IStatus.ERROR, LauncherPlugin.SYMBOLIC_NAME, IStatus.ERROR, "Collection launcher not selected.", null));		}		try {			return CollectionLauncherLoader.loadCollectionLauncher(collectionLauncherId);		} catch (ClassNotFoundException e) {			throw new CoreException(new Status(IStatus.ERROR, LauncherPlugin.SYMBOLIC_NAME, IStatus.ERROR, "Collection launcher class not found.", e));		} catch (IllegalArgumentException e) {			throw new CoreException(new Status(IStatus.ERROR, LauncherPlugin.SYMBOLIC_NAME, IStatus.ERROR, "Invalid arguments on collection launcher.", e));		} catch (NoMatchingConstructorFoundException e) {			throw new CoreException(new Status(IStatus.ERROR, LauncherPlugin.SYMBOLIC_NAME, IStatus.ERROR, "No default constructor found in collection launcher.", e));		} catch (InstantiationException e) {			throw new CoreException(new Status(IStatus.ERROR, LauncherPlugin.SYMBOLIC_NAME, IStatus.ERROR, "Error instantiating collection launcher class.", e));		} catch (IllegalAccessException e) {			throw new CoreException(new Status(IStatus.ERROR, LauncherPlugin.SYMBOLIC_NAME, IStatus.ERROR, "Error accessing collection launcher constuctors.", e));		} catch (InvocationTargetException e) {			throw new CoreException(new Status(IStatus.ERROR, LauncherPlugin.SYMBOLIC_NAME, IStatus.ERROR, "Error creating collection launcher instance.", e));		}	}		/**	 * Loads the configured ContextProvider	 * @param launchConfiguration	 * @return	 * @throws CoreException	 */	private ContextProvider getContextProvider(ILaunchConfiguration launchConfiguration) throws CoreException {		String contextProviderId=launchConfiguration.getAttribute(				LaunchConfigurationConstants.CONTEXT_PROVIDER_ID, "");		if(contextProviderId.trim().length()==0) {			throw new CoreException(new Status(IStatus.ERROR, LauncherPlugin.SYMBOLIC_NAME, IStatus.ERROR, "Context provider not selected.", null));		}		try {			return ContextProviderLoader.loadContextProvider(contextProviderId);		} catch (ClassNotFoundException e) {			throw new CoreException(new Status(IStatus.ERROR, LauncherPlugin.SYMBOLIC_NAME, IStatus.ERROR, "Context provider class not found.", e));		} catch (IllegalArgumentException e) {			throw new CoreException(new Status(IStatus.ERROR, LauncherPlugin.SYMBOLIC_NAME, IStatus.ERROR, "Invalid arguments on context provider.", e));		} catch (NoMatchingConstructorFoundException e) {			throw new CoreException(new Status(IStatus.ERROR, LauncherPlugin.SYMBOLIC_NAME, IStatus.ERROR, "No default constructor found in context provider.", e));		} catch (InstantiationException e) {			throw new CoreException(new Status(IStatus.ERROR, LauncherPlugin.SYMBOLIC_NAME, IStatus.ERROR, "Error instantiating context provider class.", e));		} catch (IllegalAccessException e) {			throw new CoreException(new Status(IStatus.ERROR, LauncherPlugin.SYMBOLIC_NAME, IStatus.ERROR, "Error accessing context provider class constuctors.", e));		} catch (InvocationTargetException e) {			throw new CoreException(new Status(IStatus.ERROR, LauncherPlugin.SYMBOLIC_NAME, IStatus.ERROR, "Error creating context provider instance.", e));		}	}	/**	 * Obtains the target LaunchConfiguration	 * @param configuration	 * @return	 * @throws CoreException	 */	private ILaunchConfiguration getTargetLaunchConfiguration(ILaunchConfiguration configuration) throws CoreException {		String launchConfigurationName=configuration.getAttribute(LaunchConfigurationConstants.TARGET_LAUNCH_CONFIGURATION, "");				ILaunchConfiguration[] launchConfigurations = DebugPlugin.getDefault().getLaunchManager().getLaunchConfigurations();		for (ILaunchConfiguration launchConfiguration : launchConfigurations) {			if(launchConfiguration.getName().equals(launchConfigurationName))				return launchConfiguration;		}		throw new CoreException(new Status(IStatus.ERROR, LauncherPlugin.SYMBOLIC_NAME, IStatus.ERROR, "Invalid launch configuration.", null));	}}
