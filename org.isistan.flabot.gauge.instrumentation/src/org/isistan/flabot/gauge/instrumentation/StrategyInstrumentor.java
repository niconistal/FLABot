/** * $Id: StrategyInstrumentor.java,v 1.19 2006/03/24 00:33:59 dacostae Exp $ * $Author: dacostae $ */package org.isistan.flabot.gauge.instrumentation;


import java.io.IOException;import java.lang.reflect.Modifier;import java.util.HashMap;import java.util.Iterator;import java.util.LinkedList;import java.util.List;import java.util.Map;import javassist.CannotCompileException;import javassist.CtBehavior;import javassist.CtClass;import javassist.CtConstructor;import javassist.CtField;import javassist.CtMethod;import javassist.NotFoundException;import javassist.expr.Cast;import javassist.expr.ConstructorCall;import javassist.expr.ExprEditor;import javassist.expr.FieldAccess;import javassist.expr.Instanceof;import javassist.expr.MethodCall;import javassist.expr.NewArray;import org.isistan.flabot.gauge.Gauge;import org.isistan.flabot.gauge.GaugeConsumer;import org.isistan.flabot.gauge.GaugeManager;import org.isistan.flabot.gauge.Strategy;import org.isistan.flabot.gauge.instrumentation.runtime.ExecutionStackPool;import org.isistan.flabot.gauge.instrumentation.runtime.GaugeManagerPool;import org.isistan.flabot.instrumentation.InstrumentationUtils;import org.isistan.flabot.instrumentation.JavassistUtils;import org.isistan.flabot.instrumentation.classloader.InstrumentationException;import org.isistan.flabot.instrumentation.classloader.Instrumentor;import org.isistan.flabot.javamodel.JBehavior;import org.isistan.flabot.javamodel.JClass;import org.isistan.flabot.javamodel.JPackage;import org.isistan.flabot.javamodel.javassist.JavassistFactory;import org.isistan.flabot.util.TriState;public class StrategyInstrumentor extends Instrumentor {
	/**
	 * Name of the gauge manager pool class
	 */
	private static final String GAUGE_MANAGER_POOL_CLASS_NAME=GaugeManagerPool.class.getName();
	
	/**	 * Name of the execution stack pool class	 */	private static final String EXECUTION_STACK_POOL_CLASS_NAME=ExecutionStackPool.class.getName();	/**
	 * Strategies to be instrumented 
	 */
	private Strategy[] strategies;
		/**	 * Determines if gauge managers created by this instrumentor are enables or disables	 */	private boolean enabled;
	/**	 * All not disposed gauge managers created by this instrumentor,	 * disposed gauge managers are removed lazily, for example, when setEnabled(boolean)	 * is called.	 */	private List<GaugeManager> gaugeManagers=new LinkedList<GaugeManager>();	
	/**
	 * Constructor 
	 * @param strategies
	 */
	public StrategyInstrumentor(Strategy[] strategies, boolean enabled) {
		this.strategies=strategies;		this.enabled=enabled;
	}		/**	 * Enables/Disables gauge managers created by this instrumentor	 * @param enabled	 */	public void setEnabled(boolean enabled) {		if(this.enabled!=enabled) {			this.enabled=enabled;			for (Iterator<GaugeManager> iterator=gaugeManagers.iterator(); iterator.hasNext();) {				GaugeManager gaugeManager = iterator.next();				if(gaugeManager.isDisposed()) {					iterator.remove();				} else {					gaugeManager.setEnabled(enabled);				}				}		}	}
	static class GaugeConsumerFilterResult {		private List<GaugeConsumer> possible=new LinkedList<GaugeConsumer>();		private List<GaugeConsumer> confirmed=new LinkedList<GaugeConsumer>();		public void addPossible(GaugeConsumer gaugeConsumer) {			possible.add(gaugeConsumer);		}		public void addConfirmed(GaugeConsumer gaugeConsumer) {			confirmed.add(gaugeConsumer);		}		public boolean isEmpty() {			return possible.size()==0 && confirmed.size()==0;		}				public List<GaugeConsumer> getPossible() {			return possible;		}				public List<GaugeConsumer> getConfirmed() {			return confirmed;		}		public boolean allConfirmed() {			return possible.size()==0;		}	}
	
	@Override
	public byte[] instrument(ClassLoader loader, String className, byte[] bytecode) throws InstrumentationException {		CtClass ctClass;
		try {
			ctClass=JavassistUtils.getCtClass(loader, className, bytecode);
		} catch (NotFoundException e) {
			String message="Class not found " + className;
			throw new InstrumentationException(message, e);
		}				if(!isValidClass(ctClass)) {			System.out.println("Invalid class: " + className);			return null;		}		JPackage jPackage=JavassistFactory.getInstance().buildPackage(ctClass.getPackageName());		GaugeConsumerFilterResult gaugeConsumersPackageSubset=getPackageGaugeConsumers(jPackage);		if(gaugeConsumersPackageSubset.isEmpty()) {			return null;		}				JClass jClass=JavassistFactory.getInstance().buildClass(ctClass);		GaugeConsumerFilterResult gaugeConsumersClassSubset=getClassGaugeConsumers(jClass, gaugeConsumersPackageSubset);		if(gaugeConsumersClassSubset.isEmpty()) {			return null;		}
		boolean modified=false;				CtBehavior[] behaviors=ctClass.getDeclaredBehaviors();
		for(CtBehavior behavior: behaviors) {			if(isEditable(behavior)) {				JBehavior jBehavior=JavassistFactory.getInstance().buildBehavior(behavior);				GaugeConsumerFilterResult gaugeConsumersBehaviorSubset=getBehaviorGaugeConsumers(jBehavior, gaugeConsumersClassSubset);
				if(!gaugeConsumersBehaviorSubset.isEmpty()) {					try {
						modified=modified | new GaugeAllocator().instrument(behavior, gaugeConsumersBehaviorSubset, loader, className, jPackage, jClass, jBehavior);						modified=true;					} catch (CannotCompileException e) {
						String message="Compilation error at " + className + "." + behavior.getName() + "()";
						throw new org.isistan.flabot.instrumentation.classloader.InstrumentationException(message, e);
					} catch (NotFoundException e) {
						String message="Javassist class not found " + className;
						throw new org.isistan.flabot.instrumentation.classloader.InstrumentationException(message, e);
					}
				}
			}			
		}

		if(!modified)
			return null;
		try {
			return ctClass.toBytecode();
		} catch (IOException e) {
			String message="IO error while generating bytecode for " + className;
			throw new InstrumentationException(message, e);
		} catch (CannotCompileException e) {
			String message="Compilation error at " + className;
			throw new InstrumentationException(message, e);
		}
		
	}

	private boolean isValidClass(CtClass ctClass) {		try {			ctClass.getModifiers();		} catch (RuntimeException e) {			if(e.getClass().equals(RuntimeException.class.getName()) && e.toString()!=null && e.toString().contains(" in ")) {				return false;			}		}		return true;	}	private GaugeConsumer[] allGaugeConsumers=null;
	private GaugeConsumer[] getAllGaugeConsumers() {
		if(this.allGaugeConsumers==null) {
			List<GaugeConsumer> allGaugeConsumers=new LinkedList<GaugeConsumer>();
			for(Strategy strategy: strategies) {
				GaugeConsumer[] gaugeConsumers=strategy.getGaugeConsumers();
				for(GaugeConsumer gaugeConsumer: gaugeConsumers) {
					allGaugeConsumers.add(gaugeConsumer);
				}
			}
			this.allGaugeConsumers = allGaugeConsumers.toArray(new GaugeConsumer[allGaugeConsumers.size()]);		}
		return this.allGaugeConsumers;
	}
		/**
	 * Returns all interested gauge consumers for the given gauge prototype
	 * @param gaugePrototype
	 * @return
	 */
	private GaugeConsumerFilterResult getPackageGaugeConsumers(JPackage jPackage) {		GaugeConsumerFilterResult result=new GaugeConsumerFilterResult();		GaugeConsumer[] gaugeConsumers=getAllGaugeConsumers();		for(GaugeConsumer gaugeConsumer: gaugeConsumers) {
			try {				TriState passes=gaugeConsumer.getFilter().passes(jPackage);				if(passes==TriState.TRUE || passes==TriState.UNDEFINED) {
					result.addConfirmed(gaugeConsumer);				}			} catch (Throwable e) {				result.addPossible(gaugeConsumer);			}		}
		return result;	}
	
	/**
	 * Determines is a method can be instrumented
	 * @param method
	 * @return
	 */
	private boolean isEditable(CtBehavior behavior) {
		int modifiers=behavior.getModifiers();
		return !Modifier.isAbstract(modifiers) &&
				!Modifier.isNative(modifiers);
	}

	/**	 * Returns all interested gauge consumers for the given class	 * @param gaugePrototype	 * @return	 */
	private GaugeConsumerFilterResult getClassGaugeConsumers(JClass jClass, GaugeConsumerFilterResult packgeSubset) {		GaugeConsumerFilterResult result=new GaugeConsumerFilterResult();		for(GaugeConsumer gaugeConsumer: packgeSubset.possible) {			try {				TriState passes=gaugeConsumer.getFilter().passes(jClass);				if(passes==TriState.TRUE || passes==TriState.UNDEFINED) {					result.addPossible(gaugeConsumer);				}			} catch (ClassCircularityError e) {				result.addPossible(gaugeConsumer);			}		}		for(GaugeConsumer gaugeConsumer: packgeSubset.confirmed) {			try {				TriState passes=gaugeConsumer.getFilter().passes(jClass);				if(passes==TriState.TRUE || passes==TriState.UNDEFINED) {					result.addConfirmed(gaugeConsumer);				}			} catch (ClassCircularityError e) {				result.addPossible(gaugeConsumer);			}		}		return result;	}	
	/**
	 * Returns all interested gauge consumers for the given behavior
	 * @param gaugePrototype
	 * @return
	 */
	private GaugeConsumerFilterResult getBehaviorGaugeConsumers(JBehavior jBehavior, GaugeConsumerFilterResult classSubset) {		GaugeConsumerFilterResult result=new GaugeConsumerFilterResult();		for(GaugeConsumer gaugeConsumer: classSubset.possible) {			try {				boolean passes=gaugeConsumer.getFilter().passes(jBehavior);				if(passes) {					result.addPossible(gaugeConsumer);				}			} catch (ClassCircularityError e) {				result.addPossible(gaugeConsumer);			}		}		for(GaugeConsumer gaugeConsumer: classSubset.confirmed) {			try {				boolean passes=gaugeConsumer.getFilter().passes(jBehavior);				if(passes) {					result.addConfirmed(gaugeConsumer);				}			} catch (ClassCircularityError e) {				result.addPossible(gaugeConsumer);			}		}		return result;	}		/**
	 * Method body visitor used to insert gauges where the gauge consumers are interested in
	 * @author $Author: dacostae $
	 *
	 */
	class GaugeAllocator extends ExprEditor {
		
		private boolean modified=false;
		private GaugeConsumerFilterResult behaviorSubset;
		private ClassLoader loader;
		private String className;		private JPackage jPackage;		private JClass jClass;		private JBehavior jBehavior;
		
		/**
		 * Allocated gauges if required 
		 * @param behavior		 * @param behaviorFilteredGaugeConsumers 		 * @param packageFilteredGaugeConsumers 
		 * @return All allocated gauges
		 * @throws CannotCompileException 
		 * @throws NotFoundException 
		 */
		public boolean instrument(CtBehavior behavior, GaugeConsumerFilterResult behaviorSubset, ClassLoader loader,				String className, JPackage jPackage, JClass jClass, JBehavior jBehavior) throws CannotCompileException, NotFoundException {			this.jPackage=jPackage;			this.jBehavior=jBehavior;			this.behaviorSubset=behaviorSubset;
			this.loader=loader;
			this.className=className;			behavior.instrument(this);
			edit(behavior, modified);
			return modified;
		}
		
		
		/**		 * Returns all interested gauge consumers for the given behavior		 * @param gaugePrototype		 * @return		 */		private GaugeConsumerFilterResult getGaugeConsumers(Gauge gauge) {			GaugeConsumerFilterResult result=new GaugeConsumerFilterResult();			for(GaugeConsumer gaugeConsumer: behaviorSubset.possible) {				try {					if(gaugeConsumer.getFilter().passes(gauge)) {						result.addPossible(gaugeConsumer);					}				} catch (ClassCircularityError e) {					result.addPossible(gaugeConsumer);				}			}			for(GaugeConsumer gaugeConsumer: behaviorSubset.confirmed) {				try {					if(gaugeConsumer.getFilter().passes(gauge)) {						result.addConfirmed(gaugeConsumer);					}				} catch (ClassCircularityError e) {					result.addPossible(gaugeConsumer);				}			}			return result;		}				/**		 * Creates a new gauge manager and adds it to the pool		 * @param gauge		 * @param gaugeConsumers		 */		private void createGaugeManager(Gauge gauge, GaugeConsumerFilterResult gaugeConsumers, CtClass valueType, CtClass[] parameterTypes) {			boolean isPrimitiveValueType=false;			if(valueType!=null) {				isPrimitiveValueType=valueType.isPrimitive();			}			boolean[] arePrimitiveParameterTypes=null;			if(parameterTypes!=null) {				arePrimitiveParameterTypes=new boolean[parameterTypes.length];				for (int i = 0; i < arePrimitiveParameterTypes.length; i++) {					arePrimitiveParameterTypes[i]=parameterTypes[i].isPrimitive();				}			}			InstrumentationGaugeManager gaugeManager=new InstrumentationGaugeManager(gauge, gaugeConsumers, jPackage, jClass, jBehavior, isPrimitiveValueType, arePrimitiveParameterTypes);			gaugeManager.setEnabled(enabled);			GaugeManagerPool.addGaugeManager(gaugeManager);			gaugeManagers.add(gaugeManager);		}
			
		/**		 * Instruments the entry, exit, an exception-exit of the method. 		 * @param behavior		 * @throws CannotCompileException		 * @throws NotFoundException		 */		private void edit(CtBehavior behavior, boolean addExecutionStackHandler) throws CannotCompileException, NotFoundException {			try {				// Build gauge prototype attributes				Map<Gauge.AttributeName, Object> attributes=new HashMap<Gauge.AttributeName, Object>();				attributes.put(Gauge.AttributeName.BEHAVIOR, jBehavior);								// Build gauge prototype				Gauge beforeGauge=new InstrumentationGauge(Gauge.Type.ON_BEHAVIOR_ENTRY, attributes, loader, className);				GaugeConsumerFilterResult beforeInterested=getGaugeConsumers(beforeGauge);				Gauge afterGauge=new InstrumentationGauge(Gauge.Type.ON_BEHAVIOR_EXIT, attributes, loader, className);				GaugeConsumerFilterResult afterInterested=getGaugeConsumers(afterGauge);				Gauge onErrorGauge=new InstrumentationGauge(Gauge.Type.ON_BEHAVIOR_ERROR, attributes, loader, className);				GaugeConsumerFilterResult onErrorInterested=getGaugeConsumers(onErrorGauge);								// Generate code				String codeBefore=null;				String codeAfter=null;				String codeOnError=null;				if(!beforeInterested.isEmpty()) {					createGaugeManager(beforeGauge, beforeInterested, null, behavior.getParameterTypes());					codeBefore=						GAUGE_MANAGER_POOL_CLASS_NAME + 						".getGaugeManager(" + beforeGauge.getId() +"L).onBehaviorEntry(" +						(Modifier.isStatic(behavior.getModifiers()) || behavior instanceof CtConstructor? "null":"this") +						",$args);";				}				if(!afterInterested.isEmpty()) {					createGaugeManager(afterGauge, afterInterested, (behavior instanceof CtMethod? ((CtMethod)behavior).getReturnType():null), behavior.getParameterTypes());					codeAfter=						GAUGE_MANAGER_POOL_CLASS_NAME + 						".getGaugeManager(" + afterGauge.getId() +"L).onBehaviorExit(" +						(Modifier.isStatic(behavior.getModifiers())? "null":"this") +						",$args,($w)$_);";				}				if(!onErrorInterested.isEmpty()) {					createGaugeManager(onErrorGauge, onErrorInterested, null, behavior.getParameterTypes());					codeOnError=						GAUGE_MANAGER_POOL_CLASS_NAME + 						".getGaugeManager(" + onErrorGauge.getId() +"L).onBehaviorError(" +						(Modifier.isStatic(behavior.getModifiers())? "null":"this") +						",$args,thrown);";				}								//add stack handler				if(codeBefore!=null || addExecutionStackHandler) {					codeBefore=EXECUTION_STACK_POOL_CLASS_NAME +".getExecutionStack().push();" + (codeBefore==null? "": codeBefore);				}				if(codeAfter!=null || addExecutionStackHandler) {					codeAfter=(codeAfter==null? "": codeAfter) + EXECUTION_STACK_POOL_CLASS_NAME +".getExecutionStack().pop();";				}				if(codeOnError!=null || addExecutionStackHandler) {					codeOnError=(codeOnError==null? "": codeOnError) + EXECUTION_STACK_POOL_CLASS_NAME +".getExecutionStack().pop();";				}								// Merge and insert code				if(codeBefore!=null) {					behavior.insertBefore(InstrumentationUtils.prepareCode(codeBefore));					modified=true;				}				if(codeAfter!=null) {					behavior.insertAfter(InstrumentationUtils.prepareCode(codeAfter));					modified=true;				}				if(codeOnError!=null) {					behavior.addCatch(InstrumentationUtils.prepareCode(codeOnError) + "throw thrown;", behavior.getDeclaringClass().getClassPool().get("java.lang.Throwable"), "thrown");					modified=true;				}			} catch (Throwable e) {				System.out.println(e.getClass().getName() + ": " + e.getMessage());				e.printStackTrace();				if(e instanceof CannotCompileException)					throw (CannotCompileException)e;				else					throw new CannotCompileException(e);			}		}						/**		 * Merges the Before, After and On Error code to be inserted.		 * de codeOnError should assume the exception variable name is		 * "thrown"		 * @param codeBefore		 * @param codeAfter		 * @param codeOnError		 * @return		 */		private String createCode(String codeBefore, String codeAfter, String codeOnError) {			return createCode(codeBefore, codeAfter, codeOnError, true, true, true);		}				/**		 * Merges the Before, After and On Error code to be inserted.		 * de codeOnError should assume the exception variable name is		 * "thrown"		 * @param codeBefore		 * @param codeAfter		 * @param codeOnError		 * @return		 */		private String createCode(String codeBefore, String codeAfter, String codeOnError, boolean prepareCodeBefore, boolean prepareCodeAfter, boolean prepareCodeOnError) {			if(codeBefore==null && codeAfter==null && codeOnError==null)				return null;			String code="{";			if(codeBefore!=null) {				if(prepareCodeBefore)					code+=InstrumentationUtils.prepareCode(codeBefore);				else					code+=codeBefore;			}			if(codeOnError!=null) {				code+="try {";			}			code+="$_=$proceed($$);";			if(codeOnError!=null) {				code+="} catch (Throwable thrown) {";				if(prepareCodeOnError)					code+=InstrumentationUtils.prepareCode(codeOnError);				else					code+=codeOnError;				code+="throw thrown;}";			}			if(codeAfter!=null) {				if(prepareCodeAfter)					code+=InstrumentationUtils.prepareCode(codeAfter);				else					code+=codeAfter;			}			code+="}";			return code;		}				@Override		public void edit(Cast cast) throws CannotCompileException {			try {				// Get target class				CtClass targetClass;				try {					targetClass=cast.getType();				} catch (NotFoundException e) {					String message="Cast target class not found while instrumenting " + cast.where().getDeclaringClass().getName() + "." + cast.where().getName();					System.out.println(message);					e.printStackTrace();					throw new CannotCompileException(message, e);				}								// Build gauge prototype attributes				Map<Gauge.AttributeName, Object> attributes=new HashMap<Gauge.AttributeName, Object>();				attributes.put(Gauge.AttributeName.BEHAVIOR, jBehavior);				attributes.put(Gauge.AttributeName.TARGET_CLASS, JavassistFactory.getInstance().buildClass(targetClass));								// Build gauge prototype				Gauge beforeGauge=new InstrumentationGauge(Gauge.Type.BEFORE_CAST, attributes, loader, className);				GaugeConsumerFilterResult beforeInterested=getGaugeConsumers(beforeGauge);				Gauge afterGauge=new InstrumentationGauge(Gauge.Type.AFTER_CAST, attributes, loader, className);				GaugeConsumerFilterResult afterInterested=getGaugeConsumers(afterGauge);				Gauge onErrorGauge=new InstrumentationGauge(Gauge.Type.ON_CAST_ERROR, attributes, loader, className);				GaugeConsumerFilterResult onErrorInterested=getGaugeConsumers(onErrorGauge);								// Generate code				String codeBefore=null;				String codeAfter=null;				String codeOnError=null;				if(!beforeInterested.isEmpty()) {					createGaugeManager(beforeGauge, beforeInterested, null, null);					codeBefore=						GAUGE_MANAGER_POOL_CLASS_NAME + 						".getGaugeManager(" + beforeGauge.getId() +"L).beforeCast(" +						(Modifier.isStatic(cast.where().getModifiers())? "null":"this") +						",$1);";				}				if(!afterInterested.isEmpty()) {					createGaugeManager(afterGauge, afterInterested, null, null);					codeAfter=						GAUGE_MANAGER_POOL_CLASS_NAME + 						".getGaugeManager(" + afterGauge.getId() +"L).afterCast(" +						(Modifier.isStatic(cast.where().getModifiers())? "null":"this") +						",$1);";				}				if(!onErrorInterested.isEmpty()) {					createGaugeManager(onErrorGauge, onErrorInterested, null, null);					codeOnError=						GAUGE_MANAGER_POOL_CLASS_NAME + 						".getGaugeManager(" + onErrorGauge.getId() +"L).onCastError(" +						(Modifier.isStatic(cast.where().getModifiers())? "null":"this") +						",$1,thrown);";				}				// Merge and insert code				String code=createCode(codeBefore, codeAfter, codeOnError);				if(code!=null) {					cast.replace(code);					modified=true;				}			} catch (Throwable e) {				System.out.println(e.getClass().getName() + ": " + e.getMessage());				e.printStackTrace();				if(e instanceof CannotCompileException)					throw (CannotCompileException)e;				else					throw new CannotCompileException(e);			}		}				@Override		public void edit(ConstructorCall constructorCall) throws CannotCompileException {			try {				// Get target constructor				CtConstructor targetConstructor;				try {					targetConstructor=constructorCall.getConstructor();				} catch (NotFoundException e) {					String message="Target constructor not found while instrumenting " + constructorCall.where().getDeclaringClass().getName() + "." + constructorCall.where().getName();					System.out.println(message);					e.printStackTrace();					throw new CannotCompileException(message, e);				}					// Build gauge prototype attributes				Map<Gauge.AttributeName, Object> attributes=new HashMap<Gauge.AttributeName, Object>();				attributes.put(Gauge.AttributeName.BEHAVIOR, jBehavior);				attributes.put(Gauge.AttributeName.TARGET_BEHAVIOR, JavassistFactory.getInstance().buildConstructor(targetConstructor));								// Build gauge prototype				Gauge beforeGauge=new InstrumentationGauge(Gauge.Type.BEFORE_CONSTRUCTOR_CALL, attributes, loader, className);				GaugeConsumerFilterResult beforeInterested=getGaugeConsumers(beforeGauge);				Gauge afterGauge=new InstrumentationGauge(Gauge.Type.AFTER_CONSTRUCTOR_CALL, attributes, loader, className);				GaugeConsumerFilterResult afterInterested=getGaugeConsumers(afterGauge);								// Generate code				String codeBefore=null;				String codeAfter=null;				if(!beforeInterested.isEmpty()) {					createGaugeManager(beforeGauge, beforeInterested, null, targetConstructor.getParameterTypes());					codeBefore=						GAUGE_MANAGER_POOL_CLASS_NAME + 						".getGaugeManager(" + beforeGauge.getId() +"L).beforeConstructorCall(" +						"$args);";				}				if(!afterInterested.isEmpty()) {					createGaugeManager(afterGauge, afterInterested, null, targetConstructor.getParameterTypes());					codeAfter=						GAUGE_MANAGER_POOL_CLASS_NAME + 						".getGaugeManager(" + afterGauge.getId() +"L).afterConstructorCall(this" +						",$args);";				}				// Merge and insert code				String code=createCode(codeBefore, codeAfter, null);				if(code!=null) {					constructorCall.replace(code);					modified=true;				}				} catch (Throwable e) {				System.out.println(e.getClass().getName() + ": " + e.getMessage());				e.printStackTrace();				if(e instanceof CannotCompileException)					throw (CannotCompileException)e;				else					throw new CannotCompileException(e);			}		}		@Override		public void edit(FieldAccess fieldAccess) throws CannotCompileException {			try {				// TODO: find workarround				// avoid editing the fields that reference to the enclosing class, because it breaks the bytecode				if(fieldAccess.getFieldName().startsWith("this$")) {					return;				}				// Get target field				CtField targetField;				try {					targetField=fieldAccess.getField();				} catch (NotFoundException e) {					String message="Target access field not found while instrumenting " + fieldAccess.where().getDeclaringClass().getName() + "." + fieldAccess.where().getName();					System.out.println(message);					e.printStackTrace();					throw new CannotCompileException(message, e);				}								// Build gauge prototype attributes				Map<Gauge.AttributeName, Object> attributes=new HashMap<Gauge.AttributeName, Object>();				attributes.put(Gauge.AttributeName.BEHAVIOR, jBehavior);				attributes.put(Gauge.AttributeName.TARGET_FIELD, JavassistFactory.getInstance().buildField(targetField));								// Build gauge prototype				Gauge.Type gaugeType;				if(fieldAccess.isReader()) {					gaugeType=Gauge.Type.ON_FIELD_READ;				} else {					gaugeType=Gauge.Type.ON_FIELD_READ;				}				Gauge accessGauge=new InstrumentationGauge(gaugeType, attributes, loader, className);				GaugeConsumerFilterResult accessInterested=getGaugeConsumers(accessGauge);								// Generate code				String beforeCode=null;				String afterCode=null;				if(!accessInterested.isEmpty()) {					createGaugeManager(accessGauge, accessInterested, targetField.getType(), null);					if(fieldAccess.isReader()) {						afterCode=							GAUGE_MANAGER_POOL_CLASS_NAME + 							".getGaugeManager(" + accessGauge.getId() +"L).onFieldRead(" +							(Modifier.isStatic(fieldAccess.where().getModifiers())? "null":"this") +							", $0, ($w)$_);";					} else {						beforeCode=							GAUGE_MANAGER_POOL_CLASS_NAME + 							".getGaugeManager(" + accessGauge.getId() +"L).onFieldWrite(" +							(Modifier.isStatic(fieldAccess.where().getModifiers())? "null":"this") +							", $0, ($w)$1" +							", ($w)(" + (Modifier.isStatic(targetField.getModifiers())? fieldAccess.getClassName(): "$0") + "." + fieldAccess.getFieldName() +							"));";												}				}				// Merge and insert code				String code=createCode(beforeCode, afterCode, null, true, false, true);				if(code!=null) {					fieldAccess.replace(code);					modified=true;				}			} catch (Throwable e) {				System.out.println(e.getClass().getName() + ": " + e.getMessage());				e.printStackTrace();				if(e instanceof CannotCompileException)					throw (CannotCompileException)e;				else					throw new CannotCompileException(e);			}		}		/*		@Override		//SOMETIMES NOT WORKING, catchExpression.getType() THROWS NULL POINTER EXCEPTION		public void edit(Handler catchExpression) throws CannotCompileException {			try {				// Get target class				CtClass targetClass;				try {					targetClass=catchExpression.getType();				} catch (NotFoundException e) {					String message="Catch target class not found while instrumenting " + catchExpression.where().getDeclaringClass().getName() + "." + catchExpression.where().getName();					System.out.println(message);					e.printStackTrace();					throw new CannotCompileException(message, e);				} catch (NullPointerException e) {					String message="NullPointerException: Catch target class not found while instrumenting " + catchExpression.where().getDeclaringClass().getName() + "." + catchExpression.where().getName();					System.out.println(message);					e.printStackTrace();					throw new CannotCompileException(message, e);				}								// Build gauge prototype attributes				Map<Gauge.AttributeName, Object> attributes=new HashMap<Gauge.AttributeName, Object>();				attributes.put(Gauge.AttributeName.BEHAVIOR, jBehavior);				attributes.put(Gauge.AttributeName.TARGET_CLASS, JavassistFactory.getInstance().buildClass(targetClass));								// Build gauge prototype				Gauge catchGauge=new InstrumentationGauge(Gauge.Type.ON_CATCH, attributes, loader, className);				GaugeConsumerFilterResult accessInterested=getGaugeConsumers(catchGauge);								// Generate code				String beforeCode=null;				if(!accessInterested.isEmpty()) {					createGaugeManager(catchGauge, accessInterested, null, null);					beforeCode=						GAUGE_MANAGER_POOL_CLASS_NAME + 						".getGaugeManager(" + catchGauge.getId() +"L).onCatch(" +						(Modifier.isStatic(catchExpression.where().getModifiers())? "null":"this") +						", $1);";				}				// Merge and insert code				if(beforeCode!=null) {					catchExpression.insertBefore(InstrumentationUtils.prepareCode(beforeCode));					modified=true;				}			} catch (Throwable e) {				System.out.println(e.getClass().getName() + ": " + e.getMessage());				e.printStackTrace();				if(e instanceof CannotCompileException)					throw (CannotCompileException)e;				else					throw new CannotCompileException(e);			}			}*/						@Override		public void edit(Instanceof instanceofExpression) throws CannotCompileException {			try {				// Get target class				CtClass targetClass;				try {					targetClass=instanceofExpression.getType();				} catch (NotFoundException e) {					String message="instanceof target class not found while instrumenting " + instanceofExpression.where().getDeclaringClass().getName() + "." + instanceofExpression.where().getName();					System.out.println(message);					e.printStackTrace();					throw new CannotCompileException(message, e);				}								// Build gauge prototype attributes				Map<Gauge.AttributeName, Object> attributes=new HashMap<Gauge.AttributeName, Object>();				attributes.put(Gauge.AttributeName.BEHAVIOR, jBehavior);				attributes.put(Gauge.AttributeName.TARGET_CLASS, JavassistFactory.getInstance().buildClass(targetClass));								// Build gauge prototype				Gauge instanceofGauge=new InstrumentationGauge(Gauge.Type.ON_INSTANCEOF_CHECK, attributes, loader, className);				GaugeConsumerFilterResult instanceofInterested=getGaugeConsumers(instanceofGauge);								// Generate code				String afterCode=null;				if(!instanceofInterested.isEmpty()) {					createGaugeManager(instanceofGauge, instanceofInterested, null, null);					afterCode=						GAUGE_MANAGER_POOL_CLASS_NAME + 						".getGaugeManager(" + instanceofGauge.getId() +"L).onInstanceofCheck(" +						(Modifier.isStatic(instanceofExpression.where().getModifiers())? "null":"this") +						", $1, $_);";				}				// Merge and insert code				String code=createCode(null, afterCode, null);				if(code!=null) {					instanceofExpression.replace(code);					modified=true;				}				} catch (Throwable e) {				System.out.println(e.getClass().getName() + ": " + e.getMessage());				e.printStackTrace();				if(e instanceof CannotCompileException)					throw (CannotCompileException)e;				else					throw new CannotCompileException(e);			}		}		@Override		public void edit(MethodCall methodCall) throws CannotCompileException {			try {				// Get target method				CtMethod targetMethod;				try {					targetMethod=methodCall.getMethod();				} catch (NotFoundException e) {					String message="Target method not found while instrumenting " + methodCall.where().getDeclaringClass().getName() + "." + methodCall.where().getName();					System.out.println(message);					e.printStackTrace();					throw new CannotCompileException(message, e);				}					// Build gauge prototype attributes				Map<Gauge.AttributeName, Object> attributes=new HashMap<Gauge.AttributeName, Object>();				attributes.put(Gauge.AttributeName.BEHAVIOR, jBehavior);				attributes.put(Gauge.AttributeName.TARGET_BEHAVIOR, JavassistFactory.getInstance().buildBehavior(targetMethod));								// Build gauge prototype				Gauge beforeGauge=new InstrumentationGauge(Gauge.Type.BEFORE_METHOD_CALL, attributes, loader, className);				GaugeConsumerFilterResult beforeInterested=getGaugeConsumers(beforeGauge);				Gauge afterGauge=new InstrumentationGauge(Gauge.Type.AFTER_METHOD_CALL, attributes, loader, className);				GaugeConsumerFilterResult afterInterested=getGaugeConsumers(afterGauge);				Gauge onErrorGauge=new InstrumentationGauge(Gauge.Type.ON_METHOD_CALL_ERROR, attributes, loader, className);				GaugeConsumerFilterResult onErrorInterested=getGaugeConsumers(onErrorGauge);								// Generate code				String codeBefore=null;				String codeAfter=null;				String codeOnError=null;				if(!beforeInterested.isEmpty()) {					createGaugeManager(beforeGauge, beforeInterested, null, targetMethod.getParameterTypes());					codeBefore=						GAUGE_MANAGER_POOL_CLASS_NAME + 						".getGaugeManager(" + beforeGauge.getId() +"L).beforeMethodCall(" +						(Modifier.isStatic(methodCall.where().getModifiers())? "null":"this") +						",$0,$args);";				}				if(!afterInterested.isEmpty()) {					createGaugeManager(afterGauge, afterInterested, targetMethod.getReturnType(), targetMethod.getParameterTypes());					codeAfter=						GAUGE_MANAGER_POOL_CLASS_NAME + 						".getGaugeManager(" + afterGauge.getId() +"L).afterMethodCall(" +						(Modifier.isStatic(methodCall.where().getModifiers())? "null":"this") +						",$0,$args,($w)$_);";				}				if(!onErrorInterested.isEmpty()) {					createGaugeManager(onErrorGauge, onErrorInterested, null, targetMethod.getParameterTypes());					codeOnError=						GAUGE_MANAGER_POOL_CLASS_NAME + 						".getGaugeManager(" + onErrorGauge.getId() +"L).onMethodCallError(" +						(Modifier.isStatic(methodCall.where().getModifiers())? "null":"this") +						",$0,$args,thrown);";				}				// Merge and insert code				String code=createCode(codeBefore, codeAfter, codeOnError, false, false, false);				if(code!=null) {					methodCall.replace(code);					modified=true;				}			} catch (Throwable e) {				System.out.println(e.getClass().getName() + ": " + e.getMessage());				e.printStackTrace();				if(e instanceof CannotCompileException)					throw (CannotCompileException)e;				else					throw new CannotCompileException(e);			}		}		@Override		public void edit(NewArray newArrayExpression) throws CannotCompileException {			try {				// Get target class				CtClass targetClass;				StringBuffer dimsString=new StringBuffer();				int dims=newArrayExpression.getDimension();				for(int i=0; i<dims; i++) {					dimsString.append("[]");				}				try {					CtClass componentType=newArrayExpression.getComponentType();					targetClass=newArrayExpression.where().getDeclaringClass().getClassPool().get(componentType.getName() + dimsString);				} catch (NotFoundException e) {					String message="Array target class not found while instrumenting " + newArrayExpression.where().getDeclaringClass().getName() + "." + newArrayExpression.where().getName();					System.out.println(message);					e.printStackTrace();					throw new CannotCompileException(message, e);				}					// Build gauge prototype attributes				Map<Gauge.AttributeName, Object> attributes=new HashMap<Gauge.AttributeName, Object>();				attributes.put(Gauge.AttributeName.BEHAVIOR, jBehavior);				attributes.put(Gauge.AttributeName.TARGET_CLASS, JavassistFactory.getInstance().buildClass(targetClass));								// Build gauge prototype				Gauge beforeGauge=new InstrumentationGauge(Gauge.Type.BEFORE_ARRAY_CREATION, attributes, loader, className);				GaugeConsumerFilterResult beforeInterested=getGaugeConsumers(beforeGauge);				Gauge afterGauge=new InstrumentationGauge(Gauge.Type.AFTER_ARRAY_CREATION, attributes, loader, className);				GaugeConsumerFilterResult afterInterested=getGaugeConsumers(afterGauge);				Gauge onErrorGauge=new InstrumentationGauge(Gauge.Type.ON_ARRAY_CREATION_ERROR, attributes, loader, className);				GaugeConsumerFilterResult onErrorInterested=getGaugeConsumers(onErrorGauge);								// Generate code				String codeBefore=null;				String codeAfter=null;				String codeOnError=null;				if(!beforeInterested.isEmpty()) {					createGaugeManager(beforeGauge, beforeInterested, null, null);					codeBefore=						GAUGE_MANAGER_POOL_CLASS_NAME + 						".getGaugeManager(" + beforeGauge.getId() +"L).beforeArrayCreation(" +						(Modifier.isStatic(newArrayExpression.where().getModifiers())? "null":"this") +						",$args);";				}				if(!afterInterested.isEmpty()) {					createGaugeManager(afterGauge, afterInterested, null, null);					codeAfter=						GAUGE_MANAGER_POOL_CLASS_NAME + 						".getGaugeManager(" + afterGauge.getId() +"L).afterArrayCreation(" +						(Modifier.isStatic(newArrayExpression.where().getModifiers())? "null":"this") +						",$args, $_);";				}				if(!onErrorInterested.isEmpty()) {					createGaugeManager(onErrorGauge, onErrorInterested, null, null);					codeOnError=						GAUGE_MANAGER_POOL_CLASS_NAME + 						".getGaugeManager(" + onErrorGauge.getId() +"L).onArrayCreationError(" +						(Modifier.isStatic(newArrayExpression.where().getModifiers())? "null":"this") +						",$args, thrown);";				}				// Merge and insert code				String code=createCode(codeBefore, codeAfter, codeOnError, false, false, false);				if(code!=null) {					newArrayExpression.replace(code);					modified=true;				}			} catch (Throwable e) {				System.out.println(e.getClass().getName() + ": " + e.getMessage());				e.printStackTrace();				if(e instanceof CannotCompileException)					throw (CannotCompileException)e;				else					throw new CannotCompileException(e);			}		}		/*		@Override		public void edit(NewExpr newExpression) throws CannotCompileException {			try {				// TODO: find workarround				// avoid instrumenting creation of 2nd or higher level nested classes instances, not supported by javassist				int first$=newExpression.getClassName().indexOf('$');				if(first$!=-1) {					int second$=newExpression.getClassName().indexOf('$', first$);					if(second$!=-1) {						return;					}				}									// Get target constructor				CtConstructor targetConstructor;				try {					targetConstructor=newExpression.getConstructor();				} catch (NotFoundException e) {					String message="new target constructor not found while instrumenting " + newExpression.where().getDeclaringClass().getName() + "." + newExpression.where().getName();					System.out.println(message);					e.printStackTrace();					throw new CannotCompileException(message, e);				}					// Build gauge prototype attributes				Map<Gauge.AttributeName, Object> attributes=new HashMap<Gauge.AttributeName, Object>();				attributes.put(Gauge.AttributeName.BEHAVIOR, jBehavior);				attributes.put(Gauge.AttributeName.TARGET_BEHAVIOR, JavassistFactory.getInstance().buildBehavior(targetConstructor));								// Build gauge prototype				Gauge beforeGauge=new InstrumentationGauge(Gauge.Type.BEFORE_CREATION, attributes, loader, className);				GaugeConsumerFilterResult beforeInterested=getGaugeConsumers(beforeGauge);				Gauge afterGauge=new InstrumentationGauge(Gauge.Type.AFTER_CREATION, attributes, loader, className);				GaugeConsumerFilterResult afterInterested=getGaugeConsumers(afterGauge);				Gauge onErrorGauge=new InstrumentationGauge(Gauge.Type.ON_CREATION_ERROR, attributes, loader, className);				GaugeConsumerFilterResult onErrorInterested=getGaugeConsumers(onErrorGauge);								// Generate code				String codeBefore=null;				String codeAfter=null;				String codeOnError=null;				if(!beforeInterested.isEmpty()) {					createGaugeManager(beforeGauge, beforeInterested, null, targetConstructor.getParameterTypes());					codeBefore=						GAUGE_MANAGER_POOL_CLASS_NAME + 						".getGaugeManager(" + beforeGauge.getId() +"L).beforeCreation(" +						(Modifier.isStatic(newExpression.where().getModifiers())? "null":"this") +						",$args);";				}				if(!afterInterested.isEmpty()) {					createGaugeManager(afterGauge, afterInterested, null, targetConstructor.getParameterTypes());					codeAfter=						GAUGE_MANAGER_POOL_CLASS_NAME + 						".getGaugeManager(" + afterGauge.getId() +"L).afterCreation(" +						(Modifier.isStatic(newExpression.where().getModifiers())? "null":"this") +						",$args, $_);";				}				if(!onErrorInterested.isEmpty()) {					createGaugeManager(onErrorGauge, onErrorInterested, null, targetConstructor.getParameterTypes());					codeOnError=						GAUGE_MANAGER_POOL_CLASS_NAME + 						".getGaugeManager(" + onErrorGauge.getId() +"L).onCreationError(" +						(Modifier.isStatic(newExpression.where().getModifiers())? "null":"this") +						",$args, thrown);";				}				// Merge and insert code				String code=createCode(codeBefore, codeAfter, codeOnError, false, false, false);				if(code!=null) {					newExpression.replace(code);					modified=true;				}			} catch (Throwable e) {				System.out.println(e.getClass().getName() + ": " + e.getMessage());				e.printStackTrace();				if(e instanceof CannotCompileException)					throw (CannotCompileException)e;				else					throw new CannotCompileException(e);			}		}*/	}	
}
