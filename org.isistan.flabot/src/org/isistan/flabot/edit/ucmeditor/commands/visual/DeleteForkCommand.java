/** * $Id: DeleteForkCommand.java,v 1.2 2006/03/21 01:51:55 franco Exp $ * $Author: franco $ */package org.isistan.flabot.edit.ucmeditor.commands.visual;import java.util.ArrayList;import java.util.Vector;import org.isistan.flabot.coremodel.CoremodelFactory;import org.isistan.flabot.coremodel.ForkNode;import org.isistan.flabot.coremodel.Path;import org.isistan.flabot.coremodel.PathNode;import org.isistan.flabot.edit.editormodel.ConnectionVisualModel;import org.isistan.flabot.edit.editormodel.EditormodelFactory;import org.isistan.flabot.edit.editormodel.NodeVisualModel;import org.isistan.flabot.edit.editormodel.Point;import org.isistan.flabot.edit.editormodel.Util;import org.isistan.flabot.edit.ucmeditor.figures.PathPointFigure;import org.isistan.flabot.edit.ucmmodel.UCMDiagram;import org.isistan.flabot.messages.Messages;/** * DeleteForkCommand * -	Removes a fork node from an existing path, splitting the path in two different paths. *  * @author $Author: franco $ * */public class DeleteForkCommand extends UpdateAllPathCommand {		private UCMDiagram diagram;		private NodeVisualModel selectedVisual;	private PathNode selectedSemantic;		private ConnectionVisualModel conPrevious;	private ConnectionVisualModel conNext1;	private Vector<ConnectionVisualModel> connectionBranchNodes = new Vector<ConnectionVisualModel>();	private NodeVisualModel previousNode;	private NodeVisualModel nextNode1;	private Vector<NodeVisualModel> branchNodes = new Vector<NodeVisualModel>();	private PathNode previousSemantic;	private PathNode nextSemantic1;	private Vector<PathNode> semanticBranchNodes = new Vector<PathNode>();	private Vector<NodeVisualModel> newStartVisualNodes = new Vector<NodeVisualModel>();	private Vector<PathNode> newStartNodes = new Vector<PathNode>();				private Path oldPath;	private Vector<Path> newPaths = new Vector<Path>();	private NodeVisualModel parent;	private Point selectedLocation;		/**	 * Create an instance of the command that deletes the fork 	 * @param visualNode the selected visual fork node to delete	 */	public DeleteForkCommand(NodeVisualModel selectedNode) {		this.selectedVisual = selectedNode;		this.selectedSemantic = (PathNode) selectedNode.getSemanticModel();		this.parent = (NodeVisualModel)selectedVisual.getParent();				for (int outputs = 0; outputs < ((ForkNode)selectedSemantic).getOutputsCount(); outputs++)		{			PathNode newStartNode = CoremodelFactory.eINSTANCE.createSimplePathNode();			newStartNodes.add(newStartNode);			NodeVisualModel newStartVisualNode = EditormodelFactory.eINSTANCE.createNodeVisualModel(selectedVisual);			newStartVisualNode.setSemanticModel(newStartNode);			newStartVisualNodes.add(newStartVisualNode);			newPaths.add(CoremodelFactory.eINSTANCE.createPath());		}		setLabel(Messages.getString("org.isistan.flabot.edit.ucmeditor.commands.visual.DeleteForkCommand.label")); //$NON-NLS-1$	}		public void execute() {		oldPath = selectedSemantic.getPath();		diagram = (UCMDiagram) selectedVisual.getDiagram();		this.selectedLocation = Util.getPoint(this.selectedVisual.getLocation().getX(), this.selectedVisual.getLocation().getY());				conNext1 = (ConnectionVisualModel)selectedVisual.getSourceConnections().get(0);		nextNode1 = conNext1.getTarget();		nextSemantic1 = (PathNode) nextNode1.getSemanticModel();				for (int i=1; i< ((ForkNode)selectedSemantic).getOutputsCount(); i++)		{			ConnectionVisualModel conNext = (ConnectionVisualModel)selectedVisual.getSourceConnections().get(i);			connectionBranchNodes.add(conNext);			 			NodeVisualModel nextNode = conNext.getTarget();			branchNodes.add(nextNode);									PathNode nextSemantic = (PathNode) nextNode.getSemanticModel();			semanticBranchNodes.add(nextSemantic);		}				conPrevious = (ConnectionVisualModel)selectedVisual.getTargetConnections().get(0);		previousNode = conPrevious.getSource();		previousSemantic = (PathNode) previousNode.getSemanticModel();				doDeleteFork();	}		private void doDeleteFork() {							conNext1.setTarget(null);		conNext1.setSource(null);		conPrevious.setSource(previousNode);		conPrevious.setTarget(nextNode1);				selectedSemantic.removeNext(nextSemantic1);		selectedSemantic.removePrevious(previousSemantic);				previousSemantic.addNext(nextSemantic1);		oldPath.getNodes().remove(selectedSemantic);				for (int outputs=0; outputs < ((ForkNode)selectedSemantic).getOutputsCount() - 1; outputs++)		{			NodeVisualModel newStartVisualNode = newStartVisualNodes.elementAt(outputs);			newStartVisualNode.setForegroundColor(selectedVisual.getForegroundColor().clone());			newStartVisualNode.setSize(Util.getDimension(PathPointFigure.defaultsize));						Path newPath = newPaths.elementAt(outputs);			PathNode newStartNode = newStartNodes.elementAt(outputs);			newPath.getNodes().add(newStartNode);			newPath.getStartNodes().add(newStartNode);						PathNode nextSemantic = semanticBranchNodes.elementAt(outputs);			selectedSemantic.removeNext(nextSemantic);				newStartNode.addNext(nextSemantic);						ConnectionVisualModel conNext = connectionBranchNodes.elementAt(outputs);			NodeVisualModel nextNode = branchNodes.elementAt(outputs);			conNext.setSemanticModel(newPath);			conNext.setSource(newStartVisualNode);			conNext.setTarget(nextNode);						newStartVisualNode.setSemanticModel(newStartNode);			newStartVisualNode.setLocation(Util.getPoint(selectedLocation.getX(), selectedLocation.getY()+ (outputs * 10)));						updateNexts(newStartVisualNode, oldPath, newPath, new ArrayList());						newStartVisualNode.setParent(selectedVisual.getParent());			if (selectedVisual.getParent() == null)				newStartVisualNode.setDiagram(diagram);						diagram.getMap().getPaths().add(newPath);		}				selectedVisual.setParent(null);		selectedVisual.setDiagram(null);			}		private void undoDeleteFork() {											selectedVisual.setSemanticModel(selectedSemantic);		selectedVisual.setParent(parent);		if (parent == null)			selectedVisual.setDiagram(diagram);				conNext1.setSemanticModel(oldPath);		conNext1.setTarget(nextNode1);		conNext1.setSource(selectedVisual);				oldPath.getNodes().add(selectedSemantic);				nextSemantic1.removePrevious(previousSemantic);		selectedSemantic.addNext(nextSemantic1);		selectedSemantic.addPrevious(previousSemantic);				conPrevious.setSemanticModel(oldPath);		conPrevious.setSource(previousNode);		conPrevious.setTarget(selectedVisual);				for (int outputs = 0; outputs < ((ForkNode)selectedSemantic).getOutputsCount() - 1; outputs++)		{			Path newPath = newPaths.elementAt(outputs);			NodeVisualModel newStartVisualNode = newStartVisualNodes.elementAt(outputs);						diagram.getMap().getPaths().remove(newPath);			updateNexts(newStartVisualNode, newPath, oldPath, new ArrayList());						ConnectionVisualModel conNext = connectionBranchNodes.elementAt(outputs);			NodeVisualModel nextNode = branchNodes.elementAt(outputs);			conNext.setSemanticModel(oldPath);			conNext.setTarget(nextNode);			conNext.setSource(selectedVisual);						newStartVisualNode.setParent(null);			newStartVisualNode.setDiagram(null);						PathNode nextSemantic = semanticBranchNodes.elementAt(outputs);			PathNode newStartNode = newStartNodes.elementAt(outputs);			nextSemantic.removePrevious(newStartNode);									selectedSemantic.addNext(nextSemantic);				}		selectedVisual.setLocation(selectedLocation);	}	public void redo() {			//execute();		doDeleteFork();	}		public void undo() {		undoDeleteFork();		}}